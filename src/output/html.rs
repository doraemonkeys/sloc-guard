use std::fmt::Write;

use crate::checker::{CheckResult, CheckStatus};
use crate::error::Result;

use super::OutputFormatter;

const HTML_HEADER: &str = r#"<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SLOC Guard Report</title>
    <style>
        :root {
            --color-passed: #22c55e;
            --color-warning: #eab308;
            --color-failed: #ef4444;
            --color-grandfathered: #3b82f6;
            --color-bg: #f8fafc;
            --color-card: #ffffff;
            --color-border: #e2e8f0;
            --color-text: #1e293b;
            --color-text-muted: #64748b;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--color-bg);
            color: var(--color-text);
            line-height: 1.6;
            padding: 2rem;
        }
        .container { max-width: 1200px; margin: 0 auto; }
        h1 { font-size: 1.875rem; font-weight: 700; margin-bottom: 1.5rem; color: var(--color-text); }
        h2 { font-size: 1.25rem; font-weight: 600; margin: 1.5rem 0 1rem; color: var(--color-text); }
        .summary-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 1rem; margin-bottom: 2rem; }
        .summary-card { background: var(--color-card); border-radius: 0.5rem; padding: 1.25rem; border: 1px solid var(--color-border); text-align: center; }
        .summary-card .value { font-size: 2rem; font-weight: 700; display: block; }
        .summary-card .label { font-size: 0.875rem; color: var(--color-text-muted); margin-top: 0.25rem; }
        .summary-card.passed .value { color: var(--color-passed); }
        .summary-card.warning .value { color: var(--color-warning); }
        .summary-card.failed .value { color: var(--color-failed); }
        .summary-card.grandfathered .value { color: var(--color-grandfathered); }
        table { width: 100%; border-collapse: collapse; background: var(--color-card); border-radius: 0.5rem; overflow: hidden; border: 1px solid var(--color-border); }
        th, td { padding: 0.75rem 1rem; text-align: left; border-bottom: 1px solid var(--color-border); }
        th { background: var(--color-bg); font-weight: 600; font-size: 0.875rem; color: var(--color-text-muted); text-transform: uppercase; letter-spacing: 0.05em; }
        td { font-size: 0.875rem; }
        td.number { text-align: right; font-variant-numeric: tabular-nums; }
        tr:last-child td { border-bottom: none; }
        tr:hover { background: var(--color-bg); }
        .status { display: inline-flex; align-items: center; gap: 0.375rem; padding: 0.25rem 0.625rem; border-radius: 9999px; font-size: 0.75rem; font-weight: 600; }
        .status.passed { background: #dcfce7; color: #166534; }
        .status.warning { background: #fef9c3; color: #854d0e; }
        .status.failed { background: #fee2e2; color: #991b1b; }
        .status.grandfathered { background: #dbeafe; color: #1e40af; }
        .file-path { font-family: 'SF Mono', SFMono-Regular, Consolas, 'Liberation Mono', Menlo, monospace; font-size: 0.8125rem; word-break: break-all; }
        .reason { font-size: 0.75rem; color: var(--color-text-muted); font-style: italic; }
        .suggestions { margin-top: 0.5rem; padding: 0.75rem; background: var(--color-bg); border-radius: 0.375rem; font-size: 0.75rem; }
        .suggestions h4 { font-size: 0.75rem; font-weight: 600; margin-bottom: 0.375rem; }
        .suggestions ul { list-style: none; margin: 0; padding: 0; }
        .suggestions li { padding: 0.25rem 0; font-family: 'SF Mono', SFMono-Regular, Consolas, monospace; }
        .footer { margin-top: 2rem; padding-top: 1rem; border-top: 1px solid var(--color-border); font-size: 0.75rem; color: var(--color-text-muted); text-align: center; }
    </style>
</head>
<body>
    <div class="container">
        <h1>SLOC Guard Report</h1>
"#;

const HTML_FOOTER: &str = r#"        <div class="footer">
            Generated by <strong>sloc-guard</strong>
        </div>
    </div>
</body>
</html>
"#;

/// HTML formatter for generating standalone HTML reports.
pub struct HtmlFormatter {
    show_suggestions: bool,
}

impl HtmlFormatter {
    #[must_use]
    pub const fn new() -> Self {
        Self {
            show_suggestions: false,
        }
    }

    #[must_use]
    pub const fn with_suggestions(mut self, show: bool) -> Self {
        self.show_suggestions = show;
        self
    }

    const fn status_class(status: &CheckStatus) -> &'static str {
        match status {
            CheckStatus::Passed => "passed",
            CheckStatus::Warning => "warning",
            CheckStatus::Failed => "failed",
            CheckStatus::Grandfathered => "grandfathered",
        }
    }

    const fn status_icon(status: &CheckStatus) -> &'static str {
        match status {
            CheckStatus::Passed => "&#x2713;",      // ✓
            CheckStatus::Warning => "&#x26A0;",     // ⚠
            CheckStatus::Failed => "&#x2717;",      // ✗
            CheckStatus::Grandfathered => "&#x25C9;", // ◉
        }
    }

    const fn status_text(status: &CheckStatus) -> &'static str {
        match status {
            CheckStatus::Passed => "Passed",
            CheckStatus::Warning => "Warning",
            CheckStatus::Failed => "Failed",
            CheckStatus::Grandfathered => "Grandfathered",
        }
    }

    fn write_html_header(output: &mut String) {
        output.push_str(HTML_HEADER);
    }

    fn write_html_footer(output: &mut String) {
        output.push_str(HTML_FOOTER);
    }

    fn write_summary(
        output: &mut String,
        total: usize,
        passed: usize,
        warnings: usize,
        failed: usize,
        grandfathered: usize,
    ) {
        output.push_str("        <div class=\"summary-grid\">\n");

        // Total files card
        writeln!(
            output,
            r#"            <div class="summary-card">
                <span class="value">{total}</span>
                <span class="label">Total Files</span>
            </div>"#
        )
        .ok();

        // Passed card
        writeln!(
            output,
            r#"            <div class="summary-card passed">
                <span class="value">{passed}</span>
                <span class="label">Passed</span>
            </div>"#
        )
        .ok();

        // Warnings card
        writeln!(
            output,
            r#"            <div class="summary-card warning">
                <span class="value">{warnings}</span>
                <span class="label">Warnings</span>
            </div>"#
        )
        .ok();

        // Failed card
        writeln!(
            output,
            r#"            <div class="summary-card failed">
                <span class="value">{failed}</span>
                <span class="label">Failed</span>
            </div>"#
        )
        .ok();

        // Grandfathered card (only if there are grandfathered files)
        if grandfathered > 0 {
            writeln!(
                output,
                r#"            <div class="summary-card grandfathered">
                <span class="value">{grandfathered}</span>
                <span class="label">Grandfathered</span>
            </div>"#
            )
            .ok();
        }

        output.push_str("        </div>\n");
    }

    fn write_file_table(&self, output: &mut String, results: &[CheckResult]) {
        // Filter non-passed results for the main table
        let non_passed: Vec<_> = results
            .iter()
            .filter(|r| !matches!(r.status, CheckStatus::Passed))
            .collect();

        if non_passed.is_empty() {
            output.push_str("        <p>All files passed the SLOC check!</p>\n");
            return;
        }

        output.push_str("        <h2>Details</h2>\n");
        output.push_str("        <table>\n");
        output.push_str("            <thead>\n");
        output.push_str("                <tr>\n");
        output.push_str("                    <th>Status</th>\n");
        output.push_str("                    <th>File</th>\n");
        output.push_str("                    <th>Lines</th>\n");
        output.push_str("                    <th>Limit</th>\n");
        output.push_str("                    <th>Code</th>\n");
        output.push_str("                    <th>Comment</th>\n");
        output.push_str("                    <th>Blank</th>\n");
        output.push_str("                </tr>\n");
        output.push_str("            </thead>\n");
        output.push_str("            <tbody>\n");

        for result in &non_passed {
            self.write_file_row(output, result);
        }

        output.push_str("            </tbody>\n");
        output.push_str("        </table>\n");
    }

    fn write_file_row(&self, output: &mut String, result: &CheckResult) {
        let class = Self::status_class(&result.status);
        let icon = Self::status_icon(&result.status);
        let text = Self::status_text(&result.status);
        let path = html_escape(&result.path.display().to_string());

        output.push_str("                <tr>\n");

        // Status cell
        writeln!(
            output,
            r#"                    <td><span class="status {class}">{icon} {text}</span></td>"#
        )
        .ok();

        // File path cell
        output.push_str("                    <td>\n");
        writeln!(output, r#"                        <div class="file-path">{path}</div>"#).ok();

        // Optional reason
        if let Some(reason) = &result.override_reason {
            let escaped_reason = html_escape(reason);
            writeln!(
                output,
                r#"                        <div class="reason">{escaped_reason}</div>"#
            )
            .ok();
        }

        // Optional split suggestions
        if self.show_suggestions
            && let Some(ref suggestion) = result.suggestions
            && suggestion.has_suggestions()
        {
            output.push_str("                        <div class=\"suggestions\">\n");
            output.push_str("                            <h4>Split suggestions:</h4>\n");
            output.push_str("                            <ul>\n");
            for chunk in &suggestion.chunks {
                let funcs = if chunk.functions.is_empty() {
                    String::new()
                } else {
                    format!(" ({})", chunk.functions.join(", "))
                };
                writeln!(
                    output,
                    r"                                <li>{}.* (~{} lines){}</li>",
                    html_escape(&chunk.suggested_name),
                    chunk.line_count,
                    html_escape(&funcs)
                )
                .ok();
            }
            output.push_str("                            </ul>\n");
            output.push_str("                        </div>\n");
        }

        output.push_str("                    </td>\n");

        // Numeric cells
        writeln!(
            output,
            r#"                    <td class="number">{}</td>"#,
            result.stats.sloc()
        )
        .ok();
        writeln!(
            output,
            r#"                    <td class="number">{}</td>"#,
            result.limit
        )
        .ok();
        writeln!(
            output,
            r#"                    <td class="number">{}</td>"#,
            result.stats.code
        )
        .ok();
        writeln!(
            output,
            r#"                    <td class="number">{}</td>"#,
            result.stats.comment
        )
        .ok();
        writeln!(
            output,
            r#"                    <td class="number">{}</td>"#,
            result.stats.blank
        )
        .ok();

        output.push_str("                </tr>\n");
    }
}

impl Default for HtmlFormatter {
    fn default() -> Self {
        Self::new()
    }
}

impl OutputFormatter for HtmlFormatter {
    fn format(&self, results: &[CheckResult]) -> Result<String> {
        let mut output = String::new();

        // Count by status
        let (passed, warnings, failed, grandfathered) =
            results
                .iter()
                .fold((0, 0, 0, 0), |(p, w, f, g), r| match r.status {
                    CheckStatus::Passed => (p + 1, w, f, g),
                    CheckStatus::Warning => (p, w + 1, f, g),
                    CheckStatus::Failed => (p, w, f + 1, g),
                    CheckStatus::Grandfathered => (p, w, f, g + 1),
                });

        Self::write_html_header(&mut output);
        Self::write_summary(
            &mut output,
            results.len(),
            passed,
            warnings,
            failed,
            grandfathered,
        );
        self.write_file_table(&mut output, results);
        Self::write_html_footer(&mut output);

        Ok(output)
    }
}

/// Escape HTML special characters.
fn html_escape(s: &str) -> String {
    s.replace('&', "&amp;")
        .replace('<', "&lt;")
        .replace('>', "&gt;")
        .replace('"', "&quot;")
        .replace('\'', "&#39;")
}

#[cfg(test)]
#[path = "html_tests.rs"]
mod tests;
