name: 'sloc-guard'
description: 'Enforce source lines of code limits and directory structure constraints'
author: 'sloc-guard'
branding:
  icon: 'file-text'
  color: 'blue'

inputs:
  paths:
    description: 'Paths to check (space-separated). Defaults to current directory'
    required: false
    default: '.'
  config-path:
    description: 'Path to sloc-guard.toml configuration file'
    required: false
    default: ''
  fail-on-warning:
    description: 'Treat warnings as failures (exit code 1)'
    required: false
    default: 'false'
  version:
    description: 'sloc-guard version to install (e.g., "0.1.0"). Use "latest" for HEAD'
    required: false
    default: 'latest'
  cache:
    description: 'Enable caching of sloc-guard results (.sloc-guard-cache.json)'
    required: false
    default: 'true'
  sarif-output:
    description: 'Path for SARIF output file. Empty to disable'
    required: false
    default: ''
  baseline:
    description: 'Path to baseline file for grandfathering existing violations'
    required: false
    default: ''
  diff:
    description: 'Only check files changed since ref (e.g., "HEAD", "origin/main")'
    required: false
    default: ''

outputs:
  total-files:
    description: 'Total number of files checked'
    value: ${{ steps.run-check.outputs.total-files }}
  passed:
    description: 'Number of files that passed'
    value: ${{ steps.run-check.outputs.passed }}
  failed:
    description: 'Number of files that failed'
    value: ${{ steps.run-check.outputs.failed }}
  warnings:
    description: 'Number of files with warnings'
    value: ${{ steps.run-check.outputs.warnings }}
  grandfathered:
    description: 'Number of grandfathered violations (from baseline)'
    value: ${{ steps.run-check.outputs.grandfathered }}
  sarif-file:
    description: 'Path to generated SARIF file (if sarif-output was specified)'
    value: ${{ steps.run-check.outputs.sarif-file }}

runs:
  using: 'composite'
  steps:
    - name: Setup Rust
      uses: dtolnay/rust-toolchain@stable

    - name: Cache cargo registry
      uses: actions/cache@v4
      with:
        path: |
          ~/.cargo/registry
          ~/.cargo/git
        key: ${{ runner.os }}-cargo-registry-${{ hashFiles('**/Cargo.lock') }}
        restore-keys: |
          ${{ runner.os }}-cargo-registry-

    - name: Detect target triple
      id: detect-target
      shell: bash
      run: |
        case "${{ runner.os }}-${{ runner.arch }}" in
          Linux-X64)   TARGET="x86_64-unknown-linux-gnu" ;;
          Linux-ARM64) TARGET="aarch64-unknown-linux-gnu" ;;
          macOS-X64)   TARGET="x86_64-apple-darwin" ;;
          macOS-ARM64) TARGET="aarch64-apple-darwin" ;;
          Windows-X64) TARGET="x86_64-pc-windows-msvc" ;;
          *)           TARGET="" ;;
        esac
        echo "target=$TARGET" >> $GITHUB_OUTPUT

    - name: Cache sloc-guard binary
      id: cache-binary
      uses: actions/cache@v4
      with:
        path: ~/.cargo/bin/sloc-guard*
        key: ${{ runner.os }}-${{ runner.arch }}-sloc-guard-${{ inputs.version }}

    - name: Install sloc-guard
      if: steps.cache-binary.outputs.cache-hit != 'true'
      shell: bash
      env:
        ACTION_REPO: ${{ github.action_repository }}
        TARGET: ${{ steps.detect-target.outputs.target }}
        VERSION: ${{ inputs.version }}
      run: |
        REPO_URL="https://github.com/${ACTION_REPO}"
        INSTALL_DIR="$HOME/.cargo/bin"
        mkdir -p "$INSTALL_DIR"

        # Function: download with exponential backoff retry
        download_with_retry() {
          local url="$1" output="$2" max_retries=3 delay=2
          for ((i=1; i<=max_retries; i++)); do
            echo "Attempt $i: Downloading $url"
            if curl -fsSL "$url" -o "$output" 2>/dev/null; then
              return 0
            fi
            if [ $i -lt $max_retries ]; then
              echo "Download failed, retrying in ${delay}s..."
              sleep $delay
              delay=$((delay * 2))
            fi
          done
          return 1
        }

        # Function: verify SHA256 checksum
        verify_checksum() {
          local file="$1" sums_file="$2" filename
          filename=$(basename "$file")
          expected=$(grep "$filename" "$sums_file" | cut -d' ' -f1)
          if [ -z "$expected" ]; then
            echo "Checksum not found for $filename"
            return 1
          fi
          echo "Verifying checksum for $filename..."
          if [ "${{ runner.os }}" = "Windows" ]; then
            actual=$(sha256sum "$file" | cut -d' ' -f1)
            if [ "$expected" = "$actual" ]; then
              return 0
            else
              echo "Checksum mismatch: expected $expected, got $actual"
              return 1
            fi
          else
            echo "$expected  $file" | sha256sum -c -
          fi
        }

        # Function: fallback to cargo install
        fallback_cargo_install() {
          echo "Falling back to cargo install..."
          if [ "$VERSION" = "latest" ]; then
            cargo install --git "$REPO_URL" --locked
          else
            cargo install --git "$REPO_URL" --tag "v$VERSION" --locked
          fi
        }

        # Skip binary download if target is unknown
        if [ -z "$TARGET" ]; then
          echo "Unknown target: ${{ runner.os }}-${{ runner.arch }}"
          fallback_cargo_install
          exit 0
        fi

        # Resolve version for "latest"
        if [ "$VERSION" = "latest" ]; then
          echo "Resolving latest version..."
          LATEST_TAG=$(curl -fsSL "https://api.github.com/repos/${ACTION_REPO}/releases/latest" 2>/dev/null | grep '"tag_name"' | sed -E 's/.*"tag_name": *"([^"]+)".*/\1/' || echo "")
          if [ -z "$LATEST_TAG" ]; then
            echo "Could not determine latest version"
            fallback_cargo_install
            exit 0
          fi
          VERSION="${LATEST_TAG#v}"
          echo "Latest version: $VERSION"
        fi

        # Determine archive extension
        if [ "${{ runner.os }}" = "Windows" ]; then
          ARCHIVE_EXT="zip"
        else
          ARCHIVE_EXT="tar.gz"
        fi

        # Construct download URLs
        BINARY_NAME="sloc-guard-${TARGET}.${ARCHIVE_EXT}"
        BINARY_URL="${REPO_URL}/releases/download/v${VERSION}/${BINARY_NAME}"
        SUMS_URL="${REPO_URL}/releases/download/v${VERSION}/SHA256SUMS"

        # Create temp directory
        TEMP_DIR=$(mktemp -d)
        trap "rm -rf '$TEMP_DIR'" EXIT

        # Download binary archive
        ARCHIVE_PATH="$TEMP_DIR/$BINARY_NAME"
        if ! download_with_retry "$BINARY_URL" "$ARCHIVE_PATH"; then
          echo "Binary download failed"
          fallback_cargo_install
          exit 0
        fi

        # Download checksums
        SUMS_PATH="$TEMP_DIR/SHA256SUMS"
        if ! download_with_retry "$SUMS_URL" "$SUMS_PATH"; then
          echo "Checksum file download failed"
          fallback_cargo_install
          exit 0
        fi

        # Verify checksum
        if ! verify_checksum "$ARCHIVE_PATH" "$SUMS_PATH"; then
          echo "Checksum verification failed"
          fallback_cargo_install
          exit 0
        fi

        # Extract archive
        echo "Extracting binary..."
        if [ "${{ runner.os }}" = "Windows" ]; then
          unzip -q "$ARCHIVE_PATH" -d "$TEMP_DIR/extracted"
        else
          mkdir -p "$TEMP_DIR/extracted"
          tar -xzf "$ARCHIVE_PATH" -C "$TEMP_DIR/extracted"
        fi

        # Find and install binary
        if [ "${{ runner.os }}" = "Windows" ]; then
          BINARY=$(find "$TEMP_DIR/extracted" -name "sloc-guard.exe" -type f | head -1)
        else
          BINARY=$(find "$TEMP_DIR/extracted" -name "sloc-guard" -type f | head -1)
        fi

        if [ -z "$BINARY" ] || [ ! -f "$BINARY" ]; then
          echo "Binary not found in archive"
          fallback_cargo_install
          exit 0
        fi

        cp "$BINARY" "$INSTALL_DIR/"
        chmod +x "$INSTALL_DIR/sloc-guard"* 2>/dev/null || true
        echo "Successfully installed sloc-guard from pre-built binary"

    - name: Generate cache key
      id: cache-key
      shell: bash
      run: |
        CONFIG_PATH="${{ inputs.config-path }}"
        if [ -z "$CONFIG_PATH" ]; then
          CONFIG_PATH="sloc-guard.toml"
        fi
        if [ -f "$CONFIG_PATH" ]; then
          CONFIG_HASH=$(sha256sum "$CONFIG_PATH" | cut -d' ' -f1 | head -c 16)
        else
          CONFIG_HASH="default"
        fi
        echo "hash=$CONFIG_HASH" >> $GITHUB_OUTPUT

    - name: Cache sloc-guard results
      if: inputs.cache == 'true'
      uses: actions/cache@v4
      with:
        path: .sloc-guard-cache.json
        key: sloc-guard-cache-${{ steps.cache-key.outputs.hash }}-${{ inputs.version }}-${{ github.sha }}
        restore-keys: |
          sloc-guard-cache-${{ steps.cache-key.outputs.hash }}-${{ inputs.version }}-

    - name: Register problem matcher
      shell: bash
      run: echo "::add-matcher::${{ github.action_path }}/problem-matcher.json"

    - name: Run sloc-guard check
      id: run-check
      shell: bash
      run: |
        ARGS=""

        # Config path
        if [ -n "${{ inputs.config-path }}" ]; then
          ARGS="$ARGS --config ${{ inputs.config-path }}"
        fi

        # Fail on warning
        if [ "${{ inputs.fail-on-warning }}" = "true" ]; then
          ARGS="$ARGS --fail-on-warning"
        fi

        # SARIF output
        SARIF_FILE=""
        if [ -n "${{ inputs.sarif-output }}" ]; then
          SARIF_FILE="${{ inputs.sarif-output }}"
          ARGS="$ARGS --format sarif"
        fi

        # Baseline
        if [ -n "${{ inputs.baseline }}" ]; then
          ARGS="$ARGS --baseline ${{ inputs.baseline }}"
        fi

        # Diff mode
        if [ -n "${{ inputs.diff }}" ]; then
          ARGS="$ARGS --diff ${{ inputs.diff }}"
        fi

        # Run check and capture output
        set +e
        if [ -n "$SARIF_FILE" ]; then
          OUTPUT=$(sloc-guard check ${{ inputs.paths }} $ARGS 2>&1)
          echo "$OUTPUT" > "$SARIF_FILE"
          # Run again for JSON and text output
          JSON_OUTPUT=$(sloc-guard check ${{ inputs.paths }} $ARGS --format json 2>&1)
          TEXT_OUTPUT=$(sloc-guard check ${{ inputs.paths }} $ARGS --format text --color never 2>&1)
          EXIT_CODE=$?
        else
          JSON_OUTPUT=$(sloc-guard check ${{ inputs.paths }} $ARGS --format json 2>&1)
          TEXT_OUTPUT=$(sloc-guard check ${{ inputs.paths }} $ARGS --format text --color never 2>&1)
          EXIT_CODE=$?
        fi
        set -e

        # Parse statistics from JSON output
        if command -v jq &> /dev/null; then
          TOTAL=$(echo "$JSON_OUTPUT" | jq -r '.summary.total_files // 0' 2>/dev/null || echo "0")
          PASSED=$(echo "$JSON_OUTPUT" | jq -r '.summary.passed // 0' 2>/dev/null || echo "0")
          FAILED=$(echo "$JSON_OUTPUT" | jq -r '.summary.failed // 0' 2>/dev/null || echo "0")
          WARNINGS=$(echo "$JSON_OUTPUT" | jq -r '.summary.warnings // 0' 2>/dev/null || echo "0")
          GRANDFATHERED=$(echo "$JSON_OUTPUT" | jq -r '.summary.grandfathered // 0' 2>/dev/null || echo "0")
        else
          TOTAL="0"
          PASSED="0"
          FAILED="0"
          WARNINGS="0"
          GRANDFATHERED="0"
        fi

        # Set outputs
        echo "total-files=$TOTAL" >> $GITHUB_OUTPUT
        echo "passed=$PASSED" >> $GITHUB_OUTPUT
        echo "failed=$FAILED" >> $GITHUB_OUTPUT
        echo "warnings=$WARNINGS" >> $GITHUB_OUTPUT
        echo "grandfathered=$GRANDFATHERED" >> $GITHUB_OUTPUT
        echo "sarif-file=$SARIF_FILE" >> $GITHUB_OUTPUT

        # Print text output for workflow logs (triggers problem matcher)
        echo "$TEXT_OUTPUT"

        # Exit with original code
        exit $EXIT_CODE

    - name: Generate Job Summary
      if: always()
      shell: bash
      env:
        TOTAL: ${{ steps.run-check.outputs.total-files }}
        PASSED: ${{ steps.run-check.outputs.passed }}
        FAILED: ${{ steps.run-check.outputs.failed }}
        WARNINGS: ${{ steps.run-check.outputs.warnings }}
        GRANDFATHERED: ${{ steps.run-check.outputs.grandfathered }}
        SARIF_FILE: ${{ steps.run-check.outputs.sarif-file }}
      run: |
        # Determine overall status
        if [ "$FAILED" = "0" ] && [ "$WARNINGS" = "0" ]; then
          STATUS_ICON="âœ…"
          STATUS_TEXT="All checks passed"
        elif [ "$FAILED" = "0" ]; then
          STATUS_ICON="âš ï¸"
          STATUS_TEXT="Passed with warnings"
        else
          STATUS_ICON="âŒ"
          STATUS_TEXT="Check failed"
        fi

        # Generate markdown summary
        {
          echo "## $STATUS_ICON sloc-guard Results"
          echo ""
          echo "**Status**: $STATUS_TEXT"
          echo ""
          echo "| Metric | Count |"
          echo "|--------|-------|"
          echo "| Total Files | $TOTAL |"
          echo "| âœ“ Passed | $PASSED |"
          echo "| âš  Warnings | $WARNINGS |"
          echo "| âœ— Failed | $FAILED |"
          echo "| â—‰ Grandfathered | $GRANDFATHERED |"
        } >> $GITHUB_STEP_SUMMARY

        # Add SARIF file info if generated
        if [ -n "$SARIF_FILE" ]; then
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ“„ SARIF output: \`$SARIF_FILE\`" >> $GITHUB_STEP_SUMMARY
        fi

    - name: Remove problem matcher
      if: always()
      shell: bash
      run: |
        echo "::remove-matcher owner=sloc-guard-error::"
        echo "::remove-matcher owner=sloc-guard-warning::"
